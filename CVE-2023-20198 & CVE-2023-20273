#the Cisco Talos research team released a python script that works in a SIEM type of environment, however I have taken their script and modified it to be able to point to a text file to scan a list of IPs running Cisco IOS XE.
# I want to share this python script here in hopes it will help others possibly locate the LUA malware aka "the implant" as discussed in this Cisco Talos advisory. https://blog.talosintelligence.com/active-exploitation-of-cisco-ios-xe-software/
# Some credit goes to @cert-orangecyberdefense (https://github.com/cert-orangecyberdefense) for having the same idea I had when I stubbled accross the difficult way to run the CURL commands against a large number of IPs to ensure the implant wasn't present.

# Fork from Atea RedTeam script. Thanks for their work
# https://github.com/Atea-Redteam/CVE-2023-20198/
# 
# Based on Cisco TALOS technical analysis work
# https://blog.talosintelligence.com/active-exploitation-of-cisco-ios-xe-software/
#

from gzip import FHCRC
import ipaddress
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed
import subprocess
import re
import argparse
import sys
import logging
import csv
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

logger = logging.getLogger(__name__)
logger.root.setLevel(logging.INFO)
logger.addHandler(FHCRC)

confirmed_ips = []
success_ips = []
failed_ips = []


def validate_ip_address(ip_string):
    try:
        ip_object = ipaddress.ip_address(ip_string)
    except ValueError:
        print(f"The IP address '{ip_string}' is not valid")


def execute_command(ip):
    # URL to check. Change to https/http or any port needed:
    url = f"https://{ip}/webui/logoutconfirm.html"
    url_curl = f"https://{ip}/webui/logoutconfirm.html?logon_hash=1"
    data = {"logon_hash": "1"}
    try:
        validate_ip_address(ip)
    except ValueError:
        return

    try:
        response = requests.post(url, data=data, timeout=2, verify=False)
        if response.status_code == 200:
            print(f"IP: {ip} - Status: {response.status_code}")
            # Check if the response content is a supicious length
            if len(response.text) < 32:
                print(f"IP: {ip} - Response is a potentially suspicious: {response.text}")
                success_ips.append(ip)
                result = subprocess.run(f'curl -k -X POST {url_curl}', capture_output=True, text=True, shell=True)
                if 18 <= len(result.stdout.strip()) <= 40:
                    confirmed_ips.append(ip)
                    logger.info(f"{ip} - PWNED")
            else:
                print(f"IP: {ip} - Response is to long.")
                failed_ips.append(ip)
                logger.info(f"{ip} - WebUI enabled but safe")

        else:
            print(f"IP: {ip} - Status: {response.status_code}")
    except requests.RequestException as e:
        print(f"IP: {ip} - Error: no reply")


def main():
    parser = argparse.ArgumentParser(description='CVE-2023-20198 IP testing')
    parser.add_argument('-a', action="store", dest="ip",
                        help="An IP address to test against CVE-2023-20198: xxx.xxx.xxx.xxx")
    parser.add_argument('-c', action="store", dest="cidr",
                        help="A CIDR address to test against CVE-2023-20198: xxx.xxx.xxx.xxx/XX")
    parser.add_argument('-f', action="store", dest="filename", help="The filename of a file listing IP addresses")
    args = parser.parse_args()
    if len(sys.argv) < 2:
        parser.print_usage()
        exit(1)

    try:
        if args.ip:
            execute_command(args.ip)
        elif args.cidr:
            # Create an IPv4Network object from the input subnet
            net = ipaddress.IPv4Network(args.cidr, strict=False)
            # Use a ThreadPoolExecutor to run execute_command concurrently
            with ThreadPoolExecutor(max_workers=15) as executor:
                # Submit tasks for each IP address in the subnet
                future_to_ip = {executor.submit(execute_command, str(ip)): ip for ip in net.hosts()}

                # Wait for all tasks to complete
                for future in as_completed(future_to_ip):
                    ip = future_to_ip[future]
                    try:
                        future.result()
                    except Exception as e:
                        print(f"IP: {ip} - Exception: {e}")

        elif args.filename:
            with open(args.filename) as f:
                data = f.read()
                data_ips = data.split("\n")

            with ThreadPoolExecutor(max_workers=15) as executor:
                future_to_ip = {executor.submit(execute_command, str(ip)): ip for ip in data_ips}

                # Wait for all tasks to complete
                for future in as_completed(future_to_ip):
                    ip = future_to_ip[future]
                    try:
                        future.result()
                    except Exception as e:
                        print(f"IP: {ip} - Exception: {e}")

    except ValueError as e:
        print(f"Error: {e}")
        print("Please enter a valid subnet in CIDR notation.")
    print("\nIPs with status code 200 and an incrimiting hash (PWNED)")
    print(confirmed_ips)
    # print("\nIPs with status code 200, suspicious length, should be checked.")
    # print(success_ips)
    print("\nIPs with status code 200, but no IOC:")
    print(failed_ips)
    with open("results.csv", "w", newline="") as csvfile:
        fieldnames = ["IP", "Status"]
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for cip in confirmed_ips: writer.writerow({"IP": cip, "Status": "PWNED"})
        for fip in failed_ips: writer.writerow({"IP": fip, "Status": "WebUI enabled but safe"})


if __name__ == "__main__":
    main()
